module Main where

import Data.List (delete, findIndex)
import Control.Monad (when)
import Data.Maybe (fromMaybe)


import Control.Concurrent (threadDelay)
import Editor.EditorState
import Editor.Viewport
import InputHandler
import Renderer
import System.Console.ANSI
import System.Directory (doesFileExist)
import System.Environment (getArgs)
import System.IO
import System.Process (callCommand)

eventLoop :: [EditorState] -> IO ()
eventLoop = unfoldM step
  where
    step :: [EditorState] -> IO (Maybe [EditorState])
    step editorStates = do
      let currentIndex = fromMaybe 0 (findIndex isRunning editorStates)
          currentState = editorStates !! currentIndex
          viewport' = viewport currentState

      renderState currentState
      inputString <- getCharRaw

      case inputString of
        "[" -> do
          let newIndex = max 0 (currentIndex - 1)
          return $ Just (moveToIndex newIndex editorStates)

        "]" -> do
          let newIndex = min (length editorStates - 1) (currentIndex + 1)
          return $ Just (moveToIndex newIndex editorStates)

        "{" -> do
          newEditorState = defaultEditorState (rows viewport') (column viewport') "" 
          return editorStates ++ [newEditorState]

        _ -> do
          newState <- handleKeyPress currentState inputString
          if isRunning newState
            then return $ Just (replaceAt currentIndex newState editorStates)
            else do
              let remainingStates = filter isRunning (replaceAt currentIndex newState editorStates)
              if null remainingStates
                then return Nothing
                else return $ Just remainingStates

moveToIndex :: Int -> [EditorState] -> [EditorState]
moveToIndex index editorStates =
  zipWith (\i state -> state { mode = if i == index then Normal else mode state }) [0..] editorStates

replaceAt :: Int -> a -> [a] -> [a]
replaceAt n newVal xs = take n xs ++ [newVal] ++ drop (n + 1) xs

-- -- Substitui o EditorState na posição dada
-- replaceAt :: Int -> a -> [a] -> [a]
-- replaceAt idx newVal xs = take idx xs ++ [newVal] ++ drop (idx + 1) xs
--
-- -- Encontra o próximo EditorState que não esteja fechado
-- findNextOpenEditorIndex :: [EditorState] -> Int -> Int
-- findNextOpenEditorIndex states currentIndex =
--   let nextIndexes = [currentIndex + 1 .. length states - 1] ++ [0 .. currentIndex - 1]
--   in fromMaybe (-1) $ findIndex (not . not(isRunning .)) (map (states !!) nextIndexes)
-- module Main where
--
-- import Control.Concurrent (threadDelay)
-- import Editor.EditorState
-- import InputHandler
-- import Renderer
-- import System.Console.ANSI
-- import System.Directory (doesFileExist)
-- import System.Environment (getArgs)
-- import System.IO
-- import System.Process (callCommand)
--
-- Read a character with a brief timeout for distinguishing ESC vs arrow keys
-- @return String that represents the character (composite or individual) received from the user.
getCharRaw :: IO String
getCharRaw = do
  char <- getChar
  if char == '\ESC'
    then do
      threadDelay 2000 -- Pequeno atraso para evitar leituras excessivas
      isCharInHandleBuffer <- hReady stdin
      if isCharInHandleBuffer
        then getChars [char] -- Captura sequência completa
        else return [char]
    else return [char]

-- Função auxiliar que captura uma sequência de caracteres
getChars :: [Char] -> IO String
getChars charArray = do
  isCharInHandleBuffer <- hReady stdin
  if isCharInHandleBuffer
    then do
      char <- getChar
      getChars (charArray ++ [char]) -- Funciona, agora vamos ter que resolver as coisas no inputHandler ;-;
    else return charArray

-- Sets the terminal configurations: disable input buffering and input echoing
setTerminalConfiguration :: IO ()
setTerminalConfiguration = do
  hSetBuffering stdin NoBuffering
  hSetEcho stdin False
  callCommand "tput rmam" -- disable terminal wrapping
  -- callCommand "stty sane" -- restore terminal wrapping
  clearScreen

-- Sets the terminal configurations to disable input character buffering and input echoing (writing the input in the terminal as it is received) and start the main event loop.
-- TODO aplicar functors para simplificar os ifs
main :: IO ()
main = do
  args <- getArgs
  Just (rows, columns) <- getTerminalSize
  setTerminalConfiguration

  startingState <- case args of
    [] -> return (defaultEditorState rows columns "") -- Default editor state if no args
    [nameOfTheFile] -> do
      exists <- doesFileExist nameOfTheFile -- Check if file exists
      if exists
        then do
          file <- readFile nameOfTheFile -- Read the file content
          return (editorStateFromFile file rows columns nameOfTheFile) -- Create EditorState from file
        else do
          return (defaultEditorState rows columns nameOfTheFile) -- Return default state if file doesn't exist
    _ -> return (defaultEditorState rows columns "") -- Fallback for extra arguments, use default state
  eventLoop [startingState]
--
-- -- Mantain the main recursion loop running. Based on the current editor state, it renders this state, process the user input and then process the new state based on it.
-- -- @param editorState :: EditorState - current state of the editor.
-- eventLoop :: EditorState -> IO ()
-- eventLoop = unfoldM step
--   where
--     step editorState = do
--       renderState editorState
--       inputString <- getCharRaw
--       newState <- handleKeyPress editorState inputString
--       return $ if isRunning newState then Just (updateEditorStateViewport newState) else Nothing
--
unfoldM :: (a -> IO (Maybe a)) -> a -> IO ()
unfoldM f a = do
  result <- f a
  maybe (return ()) (unfoldM f) result

-- Verifies if the current editor state is a valid (or running) state. If this is the case, return True, otherwise, False.
-- @param editorState :: EditorState - current state of the editor.
isRunning :: EditorState -> Bool
isRunning (EditorState Closed _ _ _ _ _ _ _ _ _ _ _) = False
isRunning _ = True
